#coding:utf-8
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 
# @param pattern string字符串 
# @return bool布尔型
#
# 贪婪匹配的思路是不正确的  应该很难穷尽所有情况
# str = "aa", pattern = "a*b*a" 就不对
# class Solution:
#     def match(self , str , pattern ):
#         # write code here
#         m = len(str)
#         n = len(pattern)
#         i = 0
#         j = 0
#         while i < n:
#             if i+1 < n and pattern[i+1] == '*':
#                 curstrlen = 0
#                 while j < m and str[j] == pattern[i]:
#                     j += 1
#                     curstrlen += 1
#                 cur_c = pattern[i]
#                 i += 2
#                 curlen = 0
#                 while i < n and pattern[i] == cur_c:
#                     if i+1 < n and pattern[i+1] == '*':
#                         i += 2
#                     else:
#                         i += 1
#                         curlen += 1
#                 if curlen > curstrlen:
#                     return False
#             else:
#                 if j >= m or str[j] != pattern[i]:
#                     return False
#                 else:
#                     j += 1
#                     i += 1
#         if j < m:
#             return False
#         return True


# 递归
# class Solution:
#     def match(self , str , pattern ):
#         if not pattern:
#             return not str
#         first_match = str and pattern[0] in {str[0], '.'}

#         if len(pattern) >= 2 and pattern[1] == '*':
#             return (self.match(str, pattern[2:])) or (first_match and self.match(str[1:], pattern))
        
#         else:
#             return first_match and self.match(str[1:], pattern[1:])


# 动态规划
class Solution:
    def match(self , str , pattern ):
        m, n = len(str), len(pattern)
        def matches(i, j):
            if i == 0:
                return False
            if pattern[j-1] == '.':
                return True
            return str[i-1] == pattern[j-1]
        dp = [[False for _ in range(n+1)] for _ in range(m+1)]
        dp[0][0] = True
        for i in range(m+1):
            for j in range(1, n+1):
                if pattern[j-1] == '*':
                    dp[i][j] |= dp[i][j-2]
                    if matches(i, j-1):
                        dp[i][j] |= dp[i-1][j]
                else:
                    if matches(i, j):
                        dp[i][j] |= dp[i-1][j-1]
        return dp[m][n]
